// Generated by CoffeeScript 1.9.1
(function() {
  var AggregateConfiguration, AggregationSettings, aggregate, count, dataString, exportAsCSV, extractFields, groupByFields, latency, mapToPoints, max, mean, min, sum, toKvp, type,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  extractFields = function(obj) {
    var fields, k, v;
    fields = [];
    for (k in obj) {
      if (!hasProp.call(obj, k)) continue;
      v = obj[k];
      fields.push({
        name: k
      });
    }
    return fields.filter(function(x) {
      return indexOf.call(facts, x) < 0;
    });
  };

  dataString = function(fields, dataPoint) {
    var j, key, len, name;
    key = "";
    for (j = 0, len = fields.length; j < len; j++) {
      name = fields[j];
      key = key + "-" + dataPoint[name];
    }
    return key;
  };

  groupByFields = function(fields, data) {
    var groupedData, j, keyedData, kvp, len, name1;
    keyedData = data.map(function(d) {
      return {
        key: dataString(fields, d),
        value: d
      };
    });
    groupedData = {};
    for (j = 0, len = keyedData.length; j < len; j++) {
      kvp = keyedData[j];
      (groupedData[name1 = kvp.key] || (groupedData[name1] = [])).push(kvp);
    }
    return groupedData;
  };

  mean = function(kvpSeq) {
    var a, acc, b, j, key, len, localLst, n, ref, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        count: 0,
        sum: 0
      };
      acc[value.x] = {
        x: value.x,
        count: n.count + 1,
        sum: n.sum + value.y
      };
    }
    localLst = [];
    for (a in acc) {
      b = acc[a];
      localLst.push(b);
    }
    return localLst.map(function(d) {
      return [d.x, d.sum / d.count];
    });
  };

  sum = function(kvpSeq) {
    var a, acc, b, j, key, len, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        sum: 0
      };
      acc[value.x] = {
        x: value.x,
        sum: n.sum + value.y
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.sum];
    });
  };

  count = function(kvpSeq) {
    var a, acc, b, j, key, len, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        count: 0
      };
      acc[value.x] = {
        x: value.x,
        count: n.count + 1
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.count];
    });
  };

  max = function(kvpSeq) {
    var a, acc, b, j, key, len, localMax, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        max: 0
      };
      localMax = n.max > value.y ? n.max : value.y;
      acc[value.x] = {
        x: value.x,
        max: localMax
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.max];
    });
  };

  min = function(kvpSeq) {
    var a, acc, b, j, key, len, localMin, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        min: value.y
      };
      localMin = n.min < value.y ? n.min : value.y;
      acc[value.x] = {
        x: value.x,
        min: localMin
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.min];
    });
  };

  mapToPoints = function(groupedData, xFunc, yField) {
    var g, groupedPoints, k;
    groupedPoints = {};
    for (k in groupedData) {
      if (!hasProp.call(groupedData, k)) continue;
      g = groupedData[k];
      (groupedPoints[k] || (groupedPoints[k] = [])).push(g.map(function(d) {
        return {
          key: d.key,
          value: {
            x: xFunc(d.value),
            y: d.value[yField]
          }
        };
      }));
    }
    return groupedPoints;
  };

  aggregate = function(groupingFields, op, xFunc, yField, data) {
    var aggregatedData, byTs, group, groupedData, groupingKey, j, len, lst, mappedPoints;
    groupedData = groupByFields(groupingFields, data);
    mappedPoints = mapToPoints(groupedData, xFunc, yField);
    aggregatedData = {};
    for (groupingKey in mappedPoints) {
      if (!hasProp.call(mappedPoints, groupingKey)) continue;
      group = mappedPoints[groupingKey];
      byTs = {};
      for (j = 0, len = group.length; j < len; j++) {
        lst = group[j];
        aggregatedData[groupingKey] = op(lst);
      }
    }
    return aggregatedData;
  };

  exportAsCSV = function(data) {
    var body, csv, d, header, j, k, key, l, len, len1, r, ref, row, v, value;
    console.log(data != null);
    if (data === {}) {
      alert("Fetch some data first.");
      return;
    }
    header = [];
    ref = data[0];
    for (k in ref) {
      if (!hasProp.call(ref, k)) continue;
      v = ref[k];
      header.push(k);
    }
    body = [];
    for (j = 0, len = data.length; j < len; j++) {
      d = data[j];
      row = [];
      for (key in d) {
        if (!hasProp.call(d, key)) continue;
        value = d[key];
        row.push(value);
      }
      body.push(row);
    }
    csv = "data:text/csv;charset=utf-8,";
    csv += header.join(",") + "\n";
    for (l = 0, len1 = body.length; l < len1; l++) {
      r = body[l];
      csv += r.join(",") + "\n";
    }
    return csv;
  };

  toKvp = function(aggregates) {
    var category, formattedData, group, results;
    formattedData = [];
    results = [];
    for (category in aggregates) {
      if (!hasProp.call(aggregates, category)) continue;
      group = aggregates[category];
      results.push(formattedData.push({
        key: category,
        values: group
      }));
    }
    return results;
  };

  type = function(obj) {
    var classToType;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = {
      '[object Boolean]': 'boolean',
      '[object Number]': 'number',
      '[object String]': 'string',
      '[object Function]': 'function',
      '[object Array]': 'array',
      '[object Date]': 'date',
      '[object RegExp]': 'regexp',
      '[object Object]': 'object'
    };
    return classToType[Object.prototype.toString.call(obj)];
  };

  AggregateConfiguration = (function() {
    function AggregateConfiguration() {}

    AggregateConfiguration.prototype.operators = [
      {
        name: "Mean",
        func: mean
      }, {
        name: "Sum",
        func: sum
      }, {
        name: "Count",
        func: count
      }, {
        name: "Max",
        func: max
      }, {
        name: "Min",
        func: min
      }
    ];

    return AggregateConfiguration;

  })();

  AggregationSettings = (function() {
    function AggregationSettings() {}

    AggregationSettings.prototype.facts = [];

    AggregationSettings.prototype.dimensions = [];

    AggregationSettings.prototype.tab = {};

    AggregationSettings.prototype.startDate = {};

    AggregationSettings.prototype.endDate = {};

    AggregationSettings.prototype.groupByFields = [];

    AggregationSettings.prototype.aggFunction = {};

    AggregationSettings.prototype.currentFact = {};

    AggregationSettings.prototype.xAxis = {};

    return AggregationSettings;

  })();

  latency = window.angular.module('latency', ['ng']);

  latency.controller('latencyCtrl', function($scope, $http, $window) {
    var retrievePreferences;
    retrievePreferences = function() {
      var k, keys, n, ref, v;
      keys = [];
      ref = $window.localStorage;
      for (k in ref) {
        v = ref[k];
        if (/View-/.test(k)) {
          n = k.replace(/View-/, "");
          keys.push({
            name: n,
            value: v
          });
        }
      }
      return keys;
    };
    $scope.configuration = new AggregateConfiguration;
    $scope.aggSettings = new AggregationSettings;
    $scope.aggSettings.facts = ["date", "sales", "covers", "discounts", "refunds"];
    $scope.aggSettings.dimensions = ["None", "dayPart", "revenueCategory", "employee"];
    $scope.aggSettings.groupByFields = [];
    $scope.params = {};
    $scope.preferences = retrievePreferences();
    $scope.showAccordians = false;
    $scope.fetching = false;
    $scope.showAggregateTable = false;
    $scope.selectedFact = {};
    $scope.fullSetAggregates = [];
    $scope.setAggregateOp = function(op) {
      return $scope.aggSettings.aggFunction = op;
    };
    $scope.setFact = function(fact) {
      return $scope.aggSettings.currentFact = fact;
    };
    $scope.toggleGrouping = function(field) {
      if (indexOf.call($scope.aggSettings.groupByFields, field) >= 0) {
        $scope.aggSettings.groupByFields.splice($scope.aggSettings.groupByFields.indexOf(field), 1);
      } else {
        $scope.aggSettings.groupByFields.push(field);
      }
      return console.log($scope.aggSettings.groupByFields);
    };
    $scope.exportMetricsToCsv = function() {
      var csv, csvUri;
      csv = exportAsCSV($scope.metrics);
      csvUri = encodeURI(csv);
      return $window.open(csvUri);
    };
    $scope.calculateAggregateKvp = function(xAxisFunc) {
      var aggregates, category, formattedData, group;
      console.log($scope.aggSettings.groupByFields);
      console.log($scope.aggSettings.currentFact);
      aggregates = aggregate($scope.aggSettings.groupByFields, $scope.aggSettings.aggFunction.func, xAxisFunc, $scope.aggSettings.currentFact, $scope.metrics);
      formattedData = [];
      for (category in aggregates) {
        if (!hasProp.call(aggregates, category)) continue;
        group = aggregates[category];
        formattedData.push({
          key: category,
          values: group
        });
      }
      return formattedData;
    };
    $scope.calculateFullSetAggregates = function() {
      var counts, k, maximums, means, minimums, n, sums, table, v, xFunc;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.showAggregateTable = true;
      xFunc = function(d) {
        return dataString($scope.aggSettings.groupByFields, d);
      };
      means = aggregate($scope.aggSettings.groupByFields, mean, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      sums = aggregate($scope.aggSettings.groupByFields, sum, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      counts = aggregate($scope.aggSettings.groupByFields, count, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      maximums = aggregate($scope.aggSettings.groupByFields, max, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      minimums = aggregate($scope.aggSettings.groupByFields, min, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      table = [];
      for (k in means) {
        v = means[k];
        n = {
          name: k,
          mean: v[0][1],
          sum: sums[k][0][1],
          count: counts[k][0][1],
          maximum: maximums[k][0][1],
          minimum: minimums[k][0][1]
        };
        table.push(n);
      }
      return $scope.fullSetAggregates = table;
    };
    $scope.showSlippage = function() {
      var category, j, len, rawData, reduced, ref, slippage, slippageData;
      $scope.showAggregateTable = false;
      d3.selectAll("svg > *").remove();
      $scope.aggSettings.tab = 1;
      slippageData = {};
      rawData = $scope.metrics.map(function(d) {
        var category, slippage;
        category = d.slippage > 0 ? 'Positive' : d.slippage < 0 ? 'Negative' : 'None';
        slippage = d.slippage;
        return {
          category: category,
          slippage: slippage
        };
      });
      for (j = 0, len = rawData.length; j < len; j++) {
        ref = rawData[j], category = ref.category, slippage = ref.slippage;
        (slippageData[category] || (slippageData[category] = [])).push({
          category: category,
          slippage: slippage
        });
      }
      reduced = $.map(slippageData, function(value, index) {
        return {
          label: index,
          val: value.length
        };
      });
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.pieChart().x(function(d) {
          return d.label;
        }).y(function(d) {
          return d.val;
        }).showLabels(true);
        d3.select("#chart svg").datum(reduced).transition().duration(1000).call(chart);
        return chart;
      });
    };
    $scope.barsByHour = function() {
      var formattedData, hours, j, k, kvpData, l, len, len1, n, ref, v, values;
      console.log("in the call");
      $scope.showAggregateTable = false;
      d3.selectAll("svg > *").remove();
      console.log("removed old svg");
      $scope.aggSettings.tab = 2;
      hours = function(d) {
        return new Date(d.date).getHours();
      };
      formattedData = $scope.calculateAggregateKvp(hours);
      kvpData = [];
      for (j = 0, len = formattedData.length; j < len; j++) {
        ref = formattedData[j], k = ref.k, values = ref.values;
        n = {
          key: k
        };
        for (l = 0, len1 = values.length; l < len1; l++) {
          v = values[l];
          n["values"] = {
            x: v[0],
            y: v[1]
          };
        }
        kvpData.push(n);
      }
      console.log(kvpData);
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.multiBarChart().transitionDuration(350).reduceXTicks(true).rotateLabels(0).showControls(true).groupSpacing(0.1);
        chart.xAxis.tickFormat(d3.format(",1f"));
        chart.yAxis.tickFormat(d3.format(",1f"));
        d3.select("#chart svg").datum(kvpData).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.barByTime = function() {
      var formattedData, heightCoefficient, tsFunc;
      $scope.showAggregateTable = false;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.aggSettings.tab = 4;
      tsFunc = function(d) {
        return d.date;
      };
      formattedData = $scope.calculateAggregateKvp(tsFunc);
      heightCoefficient = formattedData.length >= 15 ? 5 : 1;
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.multiBarChart().x(function(d) {
          return d[0];
        }).y(function(d) {
          return d[1];
        }).transitionDuration(350).reduceXTicks(true).rotateLabels(25).groupSpacing(0.01).margin({
          left: 100,
          bottom: 60
        });
        chart.xAxis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        chart.yAxis.tickFormat(d3.format(",.001f"));
        d3.select("#chart svg").datum(formattedData).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.lineByTimeFocusable = function() {
      var formattedData, tsFunc;
      $scope.showAggregateTable = false;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.aggSettings.tab = 3;
      tsFunc = function(d) {
        return d.date;
      };
      formattedData = $scope.calculateAggregateKvp(tsFunc);
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.lineWithFocusChart().x(function(d) {
          return d[0];
        }).y(function(d) {
          return d[1];
        });
        chart.xAxis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        chart.yAxis.tickFormat(d3.format(',.1f'));
        chart.y2Axis.tickFormat(d3.format(',.1f'));
        chart.x2Axis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        d3.select("#chart svg").datum(formattedData).transition().duration(500).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.validationFailed = function() {
      var failed;
      failed = false;
      if ($scope.aggSettings.groupByFields.length <= 0) {
        alert("You must group by something!");
        failed = true;
      }
      if ($scope.aggSettings.aggFunction === {}) {
        alert("You must select an aggregate opeartion!");
        failed = true;
      }
      if ($scope.aggSettings.currentFact === {}) {
        alert("You must select a fact!");
        failed = true;
      }
      return failed;
    };
    $scope.fetchMetrics = function(params) {
      var c, cat, category, d, dPart, date, dayPart, emp, emps, hours, i, j, r, rec, ref, s, sales;
      $scope.fetching = true;
      $scope.aggSettings.startDate = params.startDate;
      $scope.aggSettings.endDate = params.endDate;
      emps = ["Smith", "Josh", "Sonia", "Paraig", "Rachel"];
      category = ["Food", "Beverage", "Goods", "Other"];
      dayPart = ["Breakfast", "Lunch", "Dinner"];
      r = Math.floor(Math.random() * 3000) + 700;
      sales = [];
      for (i = j = 1, ref = r; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        s = Math.floor(Math.random() * 150) + 1;
        d = Math.floor(Math.random() * 15);
        r = s % 17 === 0 ? Math.floor(Math.random() * s) : 0;
        c = Math.floor(Math.random() * 7) + 1;
        emp = emps[s % 5];
        date = new Date(params.startDate.getTime() + (Math.random() * (params.endDate.getTime() - params.startDate.getTime())));
        cat = category[s % 4];
        dPart = dayPart[s % 3];
        hours = Math.floor(Math.random() * 14) + 7;
        date.setHours(hours);
        rec = {
          date: date,
          dayPart: dPart,
          sales: s,
          discount: d,
          refund: r,
          covers: c,
          employee: emp,
          revenueCategory: cat
        };
        sales.push(rec);
      }
      $scope.metrics = sales;
      console.log($scope.metrics);
      $scope.showAccordians = true;
      return $scope.fetching = false;
    };
    $scope.saveView = function() {
      $window.localStorage.setItem("View-" + $scope.params.newViewName, JSON.stringify($scope.aggSettings));
      console.log($window.localStorage);
      $scope.params.newVewName = "";
      return $scope.preferences = retrievePreferences();
    };
    return $scope.loadSavedView = function(name) {
      var continuation, op, ops, t;
      ops = $scope.configuration.operators;
      $scope.aggSettings = JSON.parse($window.localStorage.getItem("View-" + name));
      console.log($scope.aggSettings);
      op = ops.filter(function(o) {
        return o.name === $scope.aggSettings.aggFunction.name;
      });
      $scope.aggSettings.aggFunction = op[0];
      $scope.params.startDate = $scope.aggSettings.startDate;
      $scope.params.endDate = $scope.aggSettings.endDate;
      console.log($scope.aggSettings);
      continuation = {};
      t = $scope.aggSettings.tab;
      if (t === 1) {
        continuation = $scope.showSlippage;
      }
      if (t === 2) {
        continuation = $scope.barsByHour;
      }
      if (t === 3) {
        continuation = $scope.lineByTimeFocusable;
      }
      if (t === 4) {
        continuation = $scope.barByTime;
      }
      return $scope.fetchMetrics($scope.params, continuation);
    };
  });

  window.angular.module('app', ['latency']);

}).call(this);
