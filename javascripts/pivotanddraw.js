// Generated by CoffeeScript 1.9.1
(function() {
  var AggregateConfiguration, AggregationSettings, aggregate, count, dataString, exportAsCSV, extractFields, groupByFields, latency, mapToPoints, max, mean, min, sum, toKvp, type,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  extractFields = function(obj) {
    var fields, k, v;
    fields = [];
    for (k in obj) {
      if (!hasProp.call(obj, k)) continue;
      v = obj[k];
      fields.push({
        name: k
      });
    }
    return fields.filter(function(x) {
      return indexOf.call(facts, x) < 0;
    });
  };

  dataString = function(fields, dataPoint) {
    var j, key, len, name;
    key = "";
    for (j = 0, len = fields.length; j < len; j++) {
      name = fields[j];
      key = key + "-" + dataPoint[name];
    }
    return key;
  };

  groupByFields = function(fields, data) {
    var groupedData, j, keyedData, kvp, len, name1;
    keyedData = data.map(function(d) {
      return {
        key: dataString(fields, d),
        value: d
      };
    });
    groupedData = {};
    for (j = 0, len = keyedData.length; j < len; j++) {
      kvp = keyedData[j];
      (groupedData[name1 = kvp.key] || (groupedData[name1] = [])).push(kvp);
    }
    return groupedData;
  };

  mean = function(kvpSeq) {
    var a, acc, b, j, key, len, localLst, n, ref, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        count: 0,
        sum: 0
      };
      acc[value.x] = {
        x: value.x,
        count: n.count + 1,
        sum: n.sum + value.y
      };
    }
    localLst = [];
    for (a in acc) {
      b = acc[a];
      localLst.push(b);
    }
    return localLst.map(function(d) {
      return [d.x, d.sum / d.count];
    });
  };

  sum = function(kvpSeq) {
    var a, acc, b, j, key, len, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        sum: 0
      };
      acc[value.x] = {
        x: value.x,
        sum: n.sum + value.y
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.sum];
    });
  };

  count = function(kvpSeq) {
    var a, acc, b, j, key, len, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        count: 0
      };
      acc[value.x] = {
        x: value.x,
        count: n.count + 1
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.count];
    });
  };

  max = function(kvpSeq) {
    var a, acc, b, j, key, len, localMax, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        max: 0
      };
      localMax = n.max > value.y ? n.max : value.y;
      acc[value.x] = {
        x: value.x,
        max: localMax
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.max];
    });
  };

  min = function(kvpSeq) {
    var a, acc, b, j, key, len, localMin, n, ref, res, value;
    acc = {};
    for (j = 0, len = kvpSeq.length; j < len; j++) {
      ref = kvpSeq[j], key = ref.key, value = ref.value;
      n = acc[value.x] || {
        x: value.x,
        min: value.y
      };
      localMin = n.min < value.y ? n.min : value.y;
      acc[value.x] = {
        x: value.x,
        min: localMin
      };
    }
    res = [];
    for (a in acc) {
      b = acc[a];
      res.push(b);
    }
    return res.map(function(d) {
      return [d.x, d.min];
    });
  };

  mapToPoints = function(groupedData, xFunc, yField) {
    var g, groupedPoints, k;
    groupedPoints = {};
    for (k in groupedData) {
      if (!hasProp.call(groupedData, k)) continue;
      g = groupedData[k];
      (groupedPoints[k] || (groupedPoints[k] = [])).push(g.map(function(d) {
        return {
          key: d.key,
          value: {
            x: xFunc(d.value),
            y: d.value[yField]
          }
        };
      }));
    }
    return groupedPoints;
  };

  aggregate = function(groupingFields, op, xFunc, yField, data) {
    var aggregatedData, byTs, group, groupedData, groupingKey, j, len, lst, mappedPoints;
    groupedData = groupByFields(groupingFields, data);
    mappedPoints = mapToPoints(groupedData, xFunc, yField);
    aggregatedData = {};
    for (groupingKey in mappedPoints) {
      if (!hasProp.call(mappedPoints, groupingKey)) continue;
      group = mappedPoints[groupingKey];
      byTs = {};
      for (j = 0, len = group.length; j < len; j++) {
        lst = group[j];
        aggregatedData[groupingKey] = op(lst);
      }
    }
    return aggregatedData;
  };

  exportAsCSV = function(data) {
    var body, csv, d, header, j, k, key, len, len1, m, r, ref, row, v, value;
    console.log(data != null);
    if (data === {}) {
      alert("Fetch some data first.");
      return;
    }
    header = [];
    ref = data[0];
    for (k in ref) {
      if (!hasProp.call(ref, k)) continue;
      v = ref[k];
      header.push(k);
    }
    body = [];
    for (j = 0, len = data.length; j < len; j++) {
      d = data[j];
      row = [];
      for (key in d) {
        if (!hasProp.call(d, key)) continue;
        value = d[key];
        row.push(value);
      }
      body.push(row);
    }
    csv = "data:text/csv;charset=utf-8,";
    csv += header.join(",") + "\n";
    for (m = 0, len1 = body.length; m < len1; m++) {
      r = body[m];
      csv += r.join(",") + "\n";
    }
    return csv;
  };

  toKvp = function(aggregates) {
    var category, formattedData, group, results;
    formattedData = [];
    results = [];
    for (category in aggregates) {
      if (!hasProp.call(aggregates, category)) continue;
      group = aggregates[category];
      results.push(formattedData.push({
        key: category,
        values: group
      }));
    }
    return results;
  };

  type = function(obj) {
    var classToType;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = {
      '[object Boolean]': 'boolean',
      '[object Number]': 'number',
      '[object String]': 'string',
      '[object Function]': 'function',
      '[object Array]': 'array',
      '[object Date]': 'date',
      '[object RegExp]': 'regexp',
      '[object Object]': 'object'
    };
    return classToType[Object.prototype.toString.call(obj)];
  };

  AggregateConfiguration = (function() {
    function AggregateConfiguration() {}

    AggregateConfiguration.prototype.operators = [
      {
        name: "Mean",
        func: mean
      }, {
        name: "Sum",
        func: sum
      }, {
        name: "Count",
        func: count
      }, {
        name: "Max",
        func: max
      }, {
        name: "Min",
        func: min
      }
    ];

    return AggregateConfiguration;

  })();

  AggregationSettings = (function() {
    function AggregationSettings() {}

    AggregationSettings.prototype.facts = [];

    AggregationSettings.prototype.dimensions = [];

    AggregationSettings.prototype.tab = {};

    AggregationSettings.prototype.startDate = {};

    AggregationSettings.prototype.endDate = {};

    AggregationSettings.prototype.groupByFields = [];

    AggregationSettings.prototype.aggFunction = {};

    AggregationSettings.prototype.currentFact = {};

    AggregationSettings.prototype.xAxis = {};

    return AggregationSettings;

  })();

  latency = window.angular.module('latency', ['ng']);

  latency.controller('latencyCtrl', function($scope, $http, $window) {
    var retrievePreferences;
    retrievePreferences = function() {
      var k, keys, n, ref, v;
      keys = [];
      ref = $window.localStorage;
      for (k in ref) {
        v = ref[k];
        if (/View-/.test(k)) {
          n = k.replace(/View-/, "");
          keys.push({
            name: n,
            value: v
          });
        }
      }
      return keys;
    };
    $scope.configuration = new AggregateConfiguration;
    $scope.aggSettings = new AggregationSettings;
    $scope.aggSettings.facts = ["date", "sales", "covers", "discounts", "refunds"];
    $scope.aggSettings.dimensions = ["None", "dayPart", "revenueCategory", "employee"];
    $scope.aggSettings.groupByFields = [];
    $scope.params = {};
    $scope.preferences = retrievePreferences();
    $scope.showAccordians = false;
    $scope.fetching = false;
    $scope.showAggregateTable = false;
    $scope.selectedFact = {};
    $scope.fullSetAggregates = [];
    $scope.dataPoints = 100;
    $scope.setAggregateOp = function(op) {
      return $scope.aggSettings.aggFunction = op;
    };
    $scope.setFact = function(fact) {
      return $scope.aggSettings.currentFact = fact;
    };
    $scope.toggleGrouping = function(field) {
      if (indexOf.call($scope.aggSettings.groupByFields, field) >= 0) {
        $scope.aggSettings.groupByFields.splice($scope.aggSettings.groupByFields.indexOf(field), 1);
      } else {
        $scope.aggSettings.groupByFields.push(field);
      }
      return console.log($scope.aggSettings.groupByFields);
    };
    $scope.exportMetricsToCsv = function() {
      var csv, csvUri;
      csv = exportAsCSV($scope.metrics);
      csvUri = encodeURI(csv);
      return $window.open(csvUri);
    };
    $scope.calculateAggregateKvp = function(xAxisFunc) {
      var aggregates, category, formattedData, group;
      console.log($scope.aggSettings.groupByFields);
      console.log($scope.aggSettings.currentFact);
      aggregates = aggregate($scope.aggSettings.groupByFields, $scope.aggSettings.aggFunction.func, xAxisFunc, $scope.aggSettings.currentFact, $scope.metrics);
      formattedData = [];
      for (category in aggregates) {
        if (!hasProp.call(aggregates, category)) continue;
        group = aggregates[category];
        formattedData.push({
          key: category,
          values: group
        });
      }
      return formattedData;
    };
    $scope.calculateFullSetAggregates = function() {
      var counts, k, maximums, means, minimums, n, sums, table, v, xFunc;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.showAggregateTable = true;
      xFunc = function(d) {
        return dataString($scope.aggSettings.groupByFields, d);
      };
      means = aggregate($scope.aggSettings.groupByFields, mean, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      sums = aggregate($scope.aggSettings.groupByFields, sum, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      counts = aggregate($scope.aggSettings.groupByFields, count, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      maximums = aggregate($scope.aggSettings.groupByFields, max, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      minimums = aggregate($scope.aggSettings.groupByFields, min, xFunc, $scope.aggSettings.currentFact, $scope.metrics);
      table = [];
      for (k in means) {
        v = means[k];
        n = {
          name: k,
          mean: v[0][1],
          sum: sums[k][0][1],
          count: counts[k][0][1],
          maximum: maximums[k][0][1],
          minimum: minimums[k][0][1]
        };
        table.push(n);
      }
      return $scope.fullSetAggregates = table;
    };
    $scope.barsByHour = function() {
      var a, formattedData, hours, j, kvpData, len, len1, m, n, ref, v;
      $scope.showAggregateTable = false;
      $scope.showTmap = false;
      d3.selectAll("svg > *").remove();
      $scope.aggSettings.tab = 2;
      hours = function(d) {
        return new Date(d.date).getHours();
      };
      formattedData = $scope.calculateAggregateKvp(hours);
      console.log(formattedData);
      kvpData = [];
      for (j = 0, len = formattedData.length; j < len; j++) {
        a = formattedData[j];
        n = {
          key: a.key,
          values: []
        };
        ref = a.values;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          v = ref[m];
          n["values"].push({
            x: v[0],
            y: v[1]
          });
        }
        kvpData.push(n);
      }
      console.log(kvpData);
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.multiBarChart();
        chart.xAxis.tickFormat(d3.format(",1f"));
        chart.yAxis.tickFormat(d3.format(",1f"));
        d3.select("#chart svg").datum(kvpData).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.barsByX = function() {
      var a, formattedData, hours, j, kvpData, len, len1, m, n, ref, results, v;
      $scope.showAggregateTable = false;
      $scope.showTmap = false;
      d3.selectAll("svg > *").remove();
      $scope.aggSettings.tab = 2;
      hours = function(d) {
        return new Date(d.date).getHours();
      };
      formattedData = $scope.calculateAggregateKvp(hours);
      kvpData = [];
      results = [];
      for (j = 0, len = formattedData.length; j < len; j++) {
        a = formattedData[j];
        n = {
          key: a.key,
          values: []
        };
        ref = a.values;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          v = ref[m];
          n["values"].push({
            x: v[0],
            y: v[1]
          });
        }
        results.push(kvpData.push(n));
      }
      return results;
    };
    $scope.barByTime = function() {
      var formattedData, heightCoefficient, tsFunc;
      $scope.showAggregateTable = false;
      $scope.showTmap = false;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.aggSettings.tab = 4;
      tsFunc = function(d) {
        return d.date;
      };
      formattedData = $scope.calculateAggregateKvp(tsFunc);
      heightCoefficient = formattedData.length >= 15 ? 5 : 1;
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.multiBarChart().x(function(d) {
          return d[0];
        }).y(function(d) {
          return d[1];
        }).transitionDuration(350).reduceXTicks(true).rotateLabels(25).groupSpacing(0.01).margin({
          left: 100,
          bottom: 60
        });
        chart.xAxis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        chart.yAxis.tickFormat(d3.format(",.001f"));
        d3.select("#chart svg").datum(formattedData).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.lineByTimeFocusable = function() {
      var formattedData, tsFunc;
      $scope.showAggregateTable = false;
      $scope.showTmap = false;
      d3.selectAll("svg > *").remove();
      if ($scope.validationFailed()) {
        return;
      }
      $scope.aggSettings.tab = 3;
      tsFunc = function(d) {
        return d.date;
      };
      formattedData = $scope.calculateAggregateKvp(tsFunc);
      return nv.addGraph(function() {
        var chart;
        chart = nv.models.lineWithFocusChart().x(function(d) {
          return d[0];
        }).y(function(d) {
          return d[1];
        });
        chart.xAxis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        chart.yAxis.tickFormat(d3.format(',.1f'));
        chart.y2Axis.tickFormat(d3.format(',.1f'));
        chart.x2Axis.tickFormat(function(d) {
          return d3.time.format("%x %X")(new Date(d));
        });
        d3.select("#chart svg").datum(formattedData).transition().duration(500).call(chart);
        nv.utils.windowResize(chart.update);
        return chart;
      });
    };
    $scope.validationFailed = function() {
      var failed;
      failed = false;
      if ($scope.aggSettings.groupByFields.length <= 0) {
        alert("You must group by something!");
        failed = true;
      }
      if ($scope.aggSettings.aggFunction === {}) {
        alert("You must select an aggregate opeartion!");
        failed = true;
      }
      if ($scope.aggSettings.currentFact === {}) {
        alert("You must select a fact!");
        failed = true;
      }
      return failed;
    };
    $scope.fetchMetrics = function(params) {
      var c, cat, category, d, dPart, date, dayPart, emp, emps, hours, i, j, r, rec, ref, s, sales;
      $scope.fetching = true;
      $scope.aggSettings.startDate = params.startDate;
      $scope.aggSettings.endDate = params.endDate;
      $scope.dataPoints = params.dataPoints;
      console.log($scope.dataPoints);
      emps = ["Smith", "Josh", "Sonia", "Paraig", "Rachel"];
      category = ["Food", "Beverage", "Goods", "Other"];
      dayPart = ["Breakfast", "Lunch", "Dinner"];
      r = $scope.dataPoints;
      sales = [];
      for (i = j = 1, ref = r; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        s = Math.floor(Math.random() * 150) + 1;
        d = Math.floor(Math.random() * 15);
        r = s % 17 === 0 ? Math.floor(Math.random() * s) : 0;
        c = Math.floor(Math.random() * 7) + 1;
        emp = emps[s % 5];
        date = new Date(params.startDate.getTime() + (Math.random() * (params.endDate.getTime() - params.startDate.getTime())));
        cat = category[s % 4];
        dPart = dayPart[s % 3];
        hours = Math.floor(Math.random() * 14) + 7;
        date.setHours(hours);
        rec = {
          date: date,
          dayPart: dPart,
          sales: s,
          discount: d,
          refund: r,
          covers: c,
          employee: emp,
          revenueCategory: cat
        };
        sales.push(rec);
      }
      sales.sort(function(l, r) {
        return l.date.getTime() - r.date.getTime();
      });
      $scope.metrics = sales;
      console.log($scope.metrics);
      $scope.showAccordians = true;
      return $scope.fetching = false;
    };
    $scope.makeCatalogTree = function() {
      var j, label, len, multiplier, node, r, site, sites, tatte, tree;
      tree = [];
      sites = [
        {
          n: "Tatte Third St",
          m: 17
        }, {
          n: "Tatte Broadway",
          m: 5
        }, {
          n: "Tatte Beacon Hill",
          m: 9
        }, {
          n: "Tatte Outer Kendall",
          m: 14
        }, {
          n: "Tatte Catering",
          m: 10
        }
      ];
      r = function(n) {
        return Math.floor(Math.random() * n) + 1;
      };
      for (j = 0, len = sites.length; j < len; j++) {
        site = sites[j];
        label = site.n;
        multiplier = site.m;
        node = {
          name: label,
          children: [
            {
              name: "Food",
              children: [
                {
                  name: "Pasteries",
                  children: [
                    {
                      name: "Muffin",
                      value: r(30) * multiplier
                    }, {
                      name: "Cookie",
                      value: r(70) * multiplier
                    }, {
                      name: "Crossiant",
                      value: r(100) * multiplier
                    }, {
                      name: "Bread",
                      value: r(15) * multiplier
                    }
                  ]
                }, {
                  name: "Salads",
                  children: [
                    {
                      name: "Chicken",
                      value: r(45) * multiplier
                    }, {
                      name: "Garden",
                      value: r(84) * multiplier
                    }, {
                      name: "Steak",
                      value: r(97) * multiplier
                    }
                  ]
                }, {
                  name: "Sandwiches",
                  children: [
                    {
                      name: "PB & J",
                      value: r(57) * multiplier
                    }, {
                      name: "Tuna",
                      value: r(74) * multiplier
                    }, {
                      name: "Grilled Cheese",
                      value: r(119) * multiplier
                    }, {
                      name: "Meatball Sub",
                      value: r(159) * multiplier
                    }, {
                      name: "Chicken",
                      value: r(103) * multiplier
                    }, {
                      name: "Reuben",
                      value: r(133) * multiplier
                    }
                  ]
                }
              ]
            }, {
              name: "Beverages",
              children: [
                {
                  name: "Coffees",
                  children: [
                    {
                      name: "Drip",
                      value: r(15) * multiplier
                    }, {
                      name: "Americano",
                      value: r(22) * multiplier
                    }, {
                      name: "Cappucino",
                      value: r(31) * multiplier
                    }, {
                      name: "Espresso",
                      value: r(46) * multiplier
                    }, {
                      name: "Latte",
                      value: r(18) * multiplier
                    }
                  ]
                }, {
                  name: "Sodas",
                  children: [
                    {
                      name: "San Pelegrino",
                      value: r(33) * multiplier
                    }, {
                      name: "Coke",
                      value: r(11) * multiplier
                    }, {
                      name: "Pepsi",
                      value: r(11) * multiplier
                    }
                  ]
                }, {
                  name: "Cocktails",
                  children: [
                    {
                      name: "A",
                      value: r(10) * multiplier
                    }, {
                      name: "B",
                      value: r(20) * multiplier
                    }, {
                      name: "C",
                      value: r(30) * multiplier
                    }, {
                      name: "D",
                      value: r(40) * multiplier
                    }, {
                      name: "E",
                      value: r(50) * multiplier
                    }, {
                      name: "F",
                      value: r(60) * multiplier
                    }
                  ]
                }
              ]
            }, {
              name: "Goods",
              children: [
                {
                  name: "Books",
                  children: [
                    {
                      name: "Cookbook 1",
                      value: r(19) * multiplier
                    }, {
                      name: "Cookbook 2",
                      value: r(29) * multiplier
                    }
                  ]
                }, {
                  name: "Clothes",
                  children: [
                    {
                      name: "Apron",
                      value: r(7) * multiplier
                    }, {
                      name: "Hat",
                      value: r(7) * multiplier
                    }, {
                      name: "Tee",
                      value: r(7) * multiplier
                    }, {
                      name: "Sweatshirt",
                      value: r(7) * multiplier
                    }
                  ]
                }
              ]
            }, {
              name: "Other",
              children: [
                {
                  name: "Gift Cards",
                  children: [
                    {
                      name: "Tatte Brand",
                      value: r(70) * multiplier
                    }, {
                      name: "Processor Brand",
                      value: r(15) * multiplier
                    }, {
                      name: "Monopoly Money",
                      value: 9
                    }
                  ]
                }
              ]
            }
          ]
        };
        tree.push(node);
      }
      tatte = {
        name: "Tatte",
        children: tree
      };
      return tatte;
    };
    $scope.treeMap = function() {
      var accumulate, display, formatNumber, grandparent, height, initialize, layout, margin, name, rect, svg, tMap, text, transitioning, tree, width, x, y;
      $scope.showAggregateTable = false;
      d3.selectAll("svg > *").remove();
      $scope.aggSettings.tab = 5;
      tree = $scope.makeCatalogTree();
      margin = {
        top: 20,
        right: 0,
        bottom: 0,
        left: 0
      };
      width = 960;
      height = 500 - margin.top - margin.bottom;
      formatNumber = d3.format(",d");
      transitioning = null;
      x = d3.scale.linear().domain([0, width]).range([0, width]);
      y = d3.scale.linear().domain([0, height]).range([0, height]);
      tMap = d3.layout.treemap().children(function(d, depth) {
        if (depth) {
          return null;
        } else {
          return d._children;
        }
      }).sort(function(l, r) {
        return l.value - r.value;
      }).ratio(height / width * 0.5 * (1 + Math.sqrt(5))).round(false);
      svg = d3.select("#chart svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.bottom + margin.top).style("background", "#ddd").style("margin-left", -margin.left + "px").style("margin.right", -margin.right + "px").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")").style("shape-rendering", "crispEdges");
      grandparent = svg.append("g").attr("class", "grandparent");
      grandparent.append("rect").attr("y", -margin.top).attr("width", width).attr("height", margin.top);
      grandparent.append("text").attr("y", 6 - margin.top).attr("x", 6).attr("dy", ".75em");
      initialize = function(data) {
        data.x = 0;
        data.y = 0;
        data.dx = width;
        data.dy = height;
        return data.depth = 0;
      };
      accumulate = function(data) {
        if (data._children = data.children) {
          return data.value = data.children.reduce(function(p, v) { return p + accumulate(v); }, 0);
        } else {
          return data.value;
        }
      };
      layout = function(data) {
        var child, j, len, ref, results;
        if (data._children) {
          tMap.nodes({
            _children: data._children
          });
          ref = data._children;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            child.x = data.x + child.x * data.dx;
            child.y = data.y + child.y * data.dy;
            child.dx *= data.dx;
            child.dy *= data.dy;
            child.parent = data;
            results.push(layout(child));
          }
          return results;
        }
      };
      display = function(data) {
        var g, g1, transition;
        grandparent.datum(data.parent).on("click", function(d, i) {
          return transition(d);
        }).select("text").text(name(data));
        g1 = svg.insert("g", ".grandparent").datum(data).attr("class", "depth");
        g = g1.selectAll("g").data(data._children).enter().append("g");
        g.filter(function(d) {
          return d._children;
        }).classed("children", true).on("click", function(d, i) {
          return transition(d);
        });
        g.selectAll(".child").data(function(d) {
          return d._children || [d];
        }).enter().append("rect").attr("class", "child").call(rect);
        g.append("rect").attr("class", "parent").call(rect).append("title").text(function(d) {
          return formatNumber(d.value);
        });
        g.append("text").attr("dy", ".75em").text(function(d) {
          return d.name + ":  $" + d.value;
        }).call(text);
        transition = function(d) {
          var g2, t1, t2;
          if (transitioning || !d) {

          } else {
            transitioning = true;
            g2 = display(d);
            t1 = g1.transition().duration(750);
            t2 = g2.transition().duration(750);
            x.domain([d.x, d.x + d.dx]);
            y.domain([d.y, d.y + d.dy]);
            svg.style("shape-rendering", null);
            svg.selectAll(".depth").sort(function(l, r) {
              return l.depth - r.depth;
            });
            g2.selectAll("text").style("fill-opacity", 0);
            t1.selectAll("text").call(text).style("fill-opacity", 0);
            t2.selectAll("text").call(text).style("fill-opacity", 1);
            t1.selectAll("rect").call(rect);
            t2.selectAll("rect").call(rect);
            return t1.remove().each("end", function() {
              svg.style("shape-rendering", "crispEdges");
              return transitioning = false;
            });
          }
        };
        return g;
      };
      text = function(txt) {
        return txt.attr("x", function(d) {
          return x(d.x) + 6;
        }).attr("y", function(d) {
          return y(d.y) + 6;
        });
      };
      rect = function(rct) {
        return rct.attr("x", function(d) {
          return x(d.x);
        }).attr("y", function(d) {
          return y(d.y);
        }).attr("width", function(d) {
          return x(d.x + d.dx) - x(d.x);
        }).attr("height", function(d) {
          return y(d.y + d.dy) - y(d.y);
        });
      };
      name = function(d) {
        if (d.parent) {
          return name(d.parent) + "." + d.name;
        } else {
          return d.name;
        }
      };
      initialize(tree);
      accumulate(tree);
      layout(tree);
      return display(tree);
    };
    $scope.saveView = function() {
      $window.localStorage.setItem("View-" + $scope.params.newViewName, JSON.stringify($scope.aggSettings));
      console.log($window.localStorage);
      $scope.params.newVewName = "";
      return $scope.preferences = retrievePreferences();
    };
    return $scope.loadSavedView = function(name) {
      var continuation, op, ops, t;
      ops = $scope.configuration.operators;
      $scope.aggSettings = JSON.parse($window.localStorage.getItem("View-" + name));
      console.log($scope.aggSettings);
      op = ops.filter(function(o) {
        return o.name === $scope.aggSettings.aggFunction.name;
      });
      $scope.aggSettings.aggFunction = op[0];
      $scope.params.startDate = $scope.aggSettings.startDate;
      $scope.params.endDate = $scope.aggSettings.endDate;
      console.log($scope.aggSettings);
      continuation = {};
      t = $scope.aggSettings.tab;
      if (t === 1) {
        continuation = $scope.showSlippage;
      }
      if (t === 2) {
        continuation = $scope.barsByHour;
      }
      if (t === 3) {
        continuation = $scope.lineByTimeFocusable;
      }
      if (t === 4) {
        continuation = $scope.barByTime;
      }
      return $scope.fetchMetrics($scope.params, continuation);
    };
  });

  window.angular.module('app', ['latency']);

}).call(this);
